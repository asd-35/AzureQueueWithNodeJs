{"version":3,"file":"messages.js","sourceRoot":"","sources":["../../../../../src/generated/src/operations/messages.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is\n * regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\nimport * as Models from \"../models\";\nimport * as Mappers from \"../models/messagesMappers\";\nimport * as Parameters from \"../models/parameters\";\nimport { StorageClientContext } from \"../storageClientContext\";\n\n/** Class representing a Messages. */\nexport class Messages {\n  private readonly client: StorageClientContext;\n\n  /**\n   * Create a Messages.\n   * @param {StorageClientContext} client Reference to the service client.\n   */\n  constructor(client: StorageClientContext) {\n    this.client = client;\n  }\n\n  /**\n   * The Dequeue operation retrieves one or more messages from the front of the queue.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.MessagesDequeueResponse>\n   */\n  dequeue(options?: Models.MessagesDequeueOptionalParams): Promise<Models.MessagesDequeueResponse>;\n  /**\n   * @param callback The callback\n   */\n  dequeue(callback: coreHttp.ServiceCallback<Models.DequeuedMessageItem[]>): void;\n  /**\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  dequeue(options: Models.MessagesDequeueOptionalParams, callback: coreHttp.ServiceCallback<Models.DequeuedMessageItem[]>): void;\n  dequeue(options?: Models.MessagesDequeueOptionalParams | coreHttp.ServiceCallback<Models.DequeuedMessageItem[]>, callback?: coreHttp.ServiceCallback<Models.DequeuedMessageItem[]>): Promise<Models.MessagesDequeueResponse> {\n    return this.client.sendOperationRequest(\n      {\n        options\n      },\n      dequeueOperationSpec,\n      callback) as Promise<Models.MessagesDequeueResponse>;\n  }\n\n  /**\n   * The Clear operation deletes all messages from the specified queue.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.MessagesClearResponse>\n   */\n  clear(options?: Models.MessagesClearOptionalParams): Promise<Models.MessagesClearResponse>;\n  /**\n   * @param callback The callback\n   */\n  clear(callback: coreHttp.ServiceCallback<void>): void;\n  /**\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  clear(options: Models.MessagesClearOptionalParams, callback: coreHttp.ServiceCallback<void>): void;\n  clear(options?: Models.MessagesClearOptionalParams | coreHttp.ServiceCallback<void>, callback?: coreHttp.ServiceCallback<void>): Promise<Models.MessagesClearResponse> {\n    return this.client.sendOperationRequest(\n      {\n        options\n      },\n      clearOperationSpec,\n      callback) as Promise<Models.MessagesClearResponse>;\n  }\n\n  /**\n   * The Enqueue operation adds a new message to the back of the message queue. A visibility timeout\n   * can also be specified to make the message invisible until the visibility timeout expires. A\n   * message must be in a format that can be included in an XML request with UTF-8 encoding. The\n   * encoded message can be up to 64 KB in size for versions 2011-08-18 and newer, or 8 KB in size\n   * for previous versions.\n   * @param queueMessage A Message object which can be stored in a Queue\n   * @param [options] The optional parameters\n   * @returns Promise<Models.MessagesEnqueueResponse>\n   */\n  enqueue(queueMessage: Models.QueueMessage, options?: Models.MessagesEnqueueOptionalParams): Promise<Models.MessagesEnqueueResponse>;\n  /**\n   * @param queueMessage A Message object which can be stored in a Queue\n   * @param callback The callback\n   */\n  enqueue(queueMessage: Models.QueueMessage, callback: coreHttp.ServiceCallback<Models.EnqueuedMessage[]>): void;\n  /**\n   * @param queueMessage A Message object which can be stored in a Queue\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  enqueue(queueMessage: Models.QueueMessage, options: Models.MessagesEnqueueOptionalParams, callback: coreHttp.ServiceCallback<Models.EnqueuedMessage[]>): void;\n  enqueue(queueMessage: Models.QueueMessage, options?: Models.MessagesEnqueueOptionalParams | coreHttp.ServiceCallback<Models.EnqueuedMessage[]>, callback?: coreHttp.ServiceCallback<Models.EnqueuedMessage[]>): Promise<Models.MessagesEnqueueResponse> {\n    return this.client.sendOperationRequest(\n      {\n        queueMessage,\n        options\n      },\n      enqueueOperationSpec,\n      callback) as Promise<Models.MessagesEnqueueResponse>;\n  }\n\n  /**\n   * The Peek operation retrieves one or more messages from the front of the queue, but does not\n   * alter the visibility of the message.\n   * @param [options] The optional parameters\n   * @returns Promise<Models.MessagesPeekResponse>\n   */\n  peek(options?: Models.MessagesPeekOptionalParams): Promise<Models.MessagesPeekResponse>;\n  /**\n   * @param callback The callback\n   */\n  peek(callback: coreHttp.ServiceCallback<Models.PeekedMessageItem[]>): void;\n  /**\n   * @param options The optional parameters\n   * @param callback The callback\n   */\n  peek(options: Models.MessagesPeekOptionalParams, callback: coreHttp.ServiceCallback<Models.PeekedMessageItem[]>): void;\n  peek(options?: Models.MessagesPeekOptionalParams | coreHttp.ServiceCallback<Models.PeekedMessageItem[]>, callback?: coreHttp.ServiceCallback<Models.PeekedMessageItem[]>): Promise<Models.MessagesPeekResponse> {\n    return this.client.sendOperationRequest(\n      {\n        options\n      },\n      peekOperationSpec,\n      callback) as Promise<Models.MessagesPeekResponse>;\n  }\n}\n\n// Operation Specifications\nconst serializer = new coreHttp.Serializer(Mappers, true);\nconst dequeueOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"GET\",\n  path: \"{queueName}/messages\",\n  urlParameters: [\n    Parameters.url\n  ],\n  queryParameters: [\n    Parameters.numberOfMessages,\n    Parameters.visibilityTimeout0,\n    Parameters.timeoutInSeconds\n  ],\n  headerParameters: [\n    Parameters.version,\n    Parameters.requestId\n  ],\n  responses: {\n    200: {\n      bodyMapper: {\n        xmlElementName: \"QueueMessage\",\n        serializedName: \"parsedResponse\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DequeuedMessageItem\"\n            }\n          }\n        }\n      },\n      headersMapper: Mappers.MessagesDequeueHeaders\n    },\n    default: {\n      bodyMapper: Mappers.StorageError,\n      headersMapper: Mappers.MessagesDequeueHeaders\n    }\n  },\n  isXML: true,\n  serializer\n};\n\nconst clearOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"DELETE\",\n  path: \"{queueName}/messages\",\n  urlParameters: [\n    Parameters.url\n  ],\n  queryParameters: [\n    Parameters.timeoutInSeconds\n  ],\n  headerParameters: [\n    Parameters.version,\n    Parameters.requestId\n  ],\n  responses: {\n    204: {\n      headersMapper: Mappers.MessagesClearHeaders\n    },\n    default: {\n      bodyMapper: Mappers.StorageError,\n      headersMapper: Mappers.MessagesClearHeaders\n    }\n  },\n  isXML: true,\n  serializer\n};\n\nconst enqueueOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"POST\",\n  path: \"{queueName}/messages\",\n  urlParameters: [\n    Parameters.url\n  ],\n  queryParameters: [\n    Parameters.visibilityTimeout0,\n    Parameters.messageTimeToLive,\n    Parameters.timeoutInSeconds\n  ],\n  headerParameters: [\n    Parameters.version,\n    Parameters.requestId\n  ],\n  requestBody: {\n    parameterPath: \"queueMessage\",\n    mapper: {\n      ...Mappers.QueueMessage,\n      required: true\n    }\n  },\n  contentType: \"application/xml; charset=utf-8\",\n  responses: {\n    201: {\n      bodyMapper: {\n        xmlElementName: \"QueueMessage\",\n        serializedName: \"parsedResponse\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"EnqueuedMessage\"\n            }\n          }\n        }\n      },\n      headersMapper: Mappers.MessagesEnqueueHeaders\n    },\n    default: {\n      bodyMapper: Mappers.StorageError,\n      headersMapper: Mappers.MessagesEnqueueHeaders\n    }\n  },\n  isXML: true,\n  serializer\n};\n\nconst peekOperationSpec: coreHttp.OperationSpec = {\n  httpMethod: \"GET\",\n  path: \"{queueName}/messages\",\n  urlParameters: [\n    Parameters.url\n  ],\n  queryParameters: [\n    Parameters.numberOfMessages,\n    Parameters.timeoutInSeconds,\n    Parameters.peekonly\n  ],\n  headerParameters: [\n    Parameters.version,\n    Parameters.requestId\n  ],\n  responses: {\n    200: {\n      bodyMapper: {\n        xmlElementName: \"QueueMessage\",\n        serializedName: \"parsedResponse\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"PeekedMessageItem\"\n            }\n          }\n        }\n      },\n      headersMapper: Mappers.MessagesPeekHeaders\n    },\n    default: {\n      bodyMapper: Mappers.StorageError,\n      headersMapper: Mappers.MessagesPeekHeaders\n    }\n  },\n  isXML: true,\n  serializer\n};\n"]}